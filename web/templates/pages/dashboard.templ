package pages

import (
	"fmt"
	"github.com/dustin/go-humanize"
	"github.com/jon4hz/jellysweep/api/models"
	"github.com/jon4hz/jellysweep/web/templates"
	"github.com/mergestat/timediff"
	"sort"
	"time"
)

// formatRelativeTime formats a time.Time as a relative time string like "in 3 days"
func formatRelativeTime(t time.Time) string {
	return timediff.TimeDiff(t)
}

// formatExactDate formats a time.Time as an exact date string for tooltips
func formatExactDate(t time.Time) string {
	return t.Format("January 2, 2006 at 15:04 MST")
}

// formatFileSize formats a file size in bytes to a human-readable string
func formatFileSize(bytes int64) string {
	return humanize.Bytes(uint64(bytes))
}

// getUniqueLibraries extracts unique library names from media items
func getUniqueLibraries(items []models.MediaItem) []string {
	libraryMap := make(map[string]bool)
	var libraries []string

	for _, item := range items {
		if item.Library != "" && !libraryMap[item.Library] {
			libraryMap[item.Library] = true
			libraries = append(libraries, item.Library)
		}
	}

	return libraries
}

// StorageCleanupPoint represents a point in time with cumulative storage freed
type StorageCleanupPoint struct {
	Date            time.Time
	CumulativeBytes int64
	ItemsDeleted    int
}

// calculateStorageCleanupData processes media items to create data points for the storage cleanup graph
func calculateStorageCleanupData(items []models.MediaItem) []StorageCleanupPoint {
	if len(items) == 0 {
		return []StorageCleanupPoint{}
	}

	// Sort items by deletion date
	sortedItems := make([]models.MediaItem, len(items))
	copy(sortedItems, items)
	sort.Slice(sortedItems, func(i, j int) bool {
		return sortedItems[i].DeletionDate.Before(sortedItems[j].DeletionDate)
	})

	var points []StorageCleanupPoint
	var cumulativeBytes int64
	var itemsDeleted int

	// Start from the first deletion date instead of now
	firstDeletionDate := sortedItems[0].DeletionDate
	points = append(points, StorageCleanupPoint{
		Date:            firstDeletionDate,
		CumulativeBytes: 0,
		ItemsDeleted:    0,
	})

	// Calculate cumulative storage freed at each deletion date
	for _, item := range sortedItems {
		cumulativeBytes += item.FileSize
		itemsDeleted++

		points = append(points, StorageCleanupPoint{
			Date:            item.DeletionDate,
			CumulativeBytes: cumulativeBytes,
			ItemsDeleted:    itemsDeleted,
		})
	}

	return points
}

// getTotalStorageToFree calculates the total storage that will be freed
func getTotalStorageToFree(items []models.MediaItem) int64 {
	var total int64
	for _, item := range items {
		total += item.FileSize
	}
	return total
}

// ChartData represents the structure for chart JSON data
type ChartData struct {
	Points       []ChartPoint `json:"points"`
	TotalStorage int64        `json:"totalStorage"`
}

// ChartPoint represents a single data point for the chart with proper JSON formatting
type ChartPoint struct {
	Date            string `json:"date"`
	CumulativeBytes int64  `json:"cumulativeBytes"`
	ItemsDeleted    int    `json:"itemsDeleted"`
}

// generateCleanupData creates the data structure for the cleanup chart
func generateCleanupData(points []StorageCleanupPoint, totalStorage int64) ChartData {
	chartPoints := make([]ChartPoint, len(points))
	for i, point := range points {
		chartPoints[i] = ChartPoint{
			Date:            point.Date.Format("2006-01-02T15:04:05Z07:00"),
			CumulativeBytes: point.CumulativeBytes,
			ItemsDeleted:    point.ItemsDeleted,
		}
	}

	return ChartData{
		Points:       chartPoints,
		TotalStorage: totalStorage,
	}
}

templ Dashboard(user *models.User, mediaItems []models.MediaItem) {
	@templates.Layout("Dashboard", user) {
		<div class="space-y-6">
			<!-- Header -->
			<div class="flex flex-col sm:flex-row sm:items-center sm:justify-between">
				<div>
					<h1 class="text-3xl font-bold text-gray-100">Media Dashboard</h1>
					<p class="mt-1 text-sm text-gray-400">
						Manage media scheduled for deletion from your libraries
					</p>
				</div>
				<div class="mt-4 sm:mt-0">
					if len(mediaItems) == 0 {
						<span class="inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-green-900 text-green-200">
							No items scheduled for deletion
						</span>
					} else {
						<span class="inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-red-900 text-red-200">
							{ len(mediaItems) } items scheduled for deletion
						</span>
					}
				</div>
			</div>
			@DashboardTabs(mediaItems)
		</div>
		<!-- Include shared utility scripts -->
		@templates.ToastScript()
		@templates.ButtonLoadingUtils()
		@templates.ApiUtils()
		@templates.DebounceUtil()
		@dashboardScripts()
	}
}

// DashboardTabs creates the tab interface for the dashboard
templ DashboardTabs(mediaItems []models.MediaItem) {
	<!-- Tab Navigation -->
	<div class="flex justify-start mb-6">
		<div class="inline-flex bg-gray-800/90 backdrop-blur-sm rounded-xl p-1.5 border border-gray-700/20 shadow-lg">
			<nav class="flex space-x-1 relative">
				<!-- Animated sliding background -->
				<div id="tab-slider" class="absolute top-1.5 left-1.5 bg-gradient-to-r from-indigo-600 to-indigo-500 rounded-lg transition-all duration-300 ease-in-out shadow-md" style="width: 0; height: calc(100% - 12px); z-index: 0;"></div>
				<button id="deletion-queue-tab" class="tab-button tab-active relative z-10 flex items-center px-5 py-3 text-sm font-semibold rounded-lg transition-all duration-300 text-white shadow-sm" data-tab="deletion-queue">
					<svg class="w-4 h-4 mr-2.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path>
					</svg>
					Overview
				</button>
				if len(mediaItems) > 0 {
					<button id="cleanup-timeline-tab" class="tab-button relative z-10 flex items-center px-5 py-3 text-sm font-semibold rounded-lg transition-all duration-300 text-gray-400 hover:text-gray-200 hover:bg-gray-700/30" data-tab="cleanup-timeline">
						<svg class="w-4 h-4 mr-2.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
						</svg>
						Stats
					</button>
				}
			</nav>
		</div>
	</div>
	<!-- Tab Content -->
	<div id="tab-content">
		<!-- Deletion Queue Tab -->
		<div id="deletion-queue-content" class="tab-content tab-content-active">
			@OverviewTab(mediaItems)
		</div>
		<!-- Stats Tab -->
		if len(mediaItems) > 0 {
			<div id="cleanup-timeline-content" class="tab-content hidden">
				@StatsTab(mediaItems)
			</div>
		}
	</div>
}

templ StorageCleanupGraph(cleanupPoints []StorageCleanupPoint, totalStorage int64) {
	<div class="card p-6">
		<div class="flex items-center justify-between mb-6">
			<div>
				<h2 class="text-xl font-semibold text-gray-100">Storage Cleanup Timeline</h2>
				<p class="text-sm text-gray-400 mt-1">Cumulative storage freed over time</p>
			</div>
			<div class="text-right">
				<div class="text-lg font-semibold text-green-400">{ formatFileSize(totalStorage) }</div>
				<div class="text-sm text-gray-400">Total to be freed</div>
			</div>
		</div>
		if len(cleanupPoints) > 1 {
			<div class="relative">
				<!-- Chart.js Canvas -->
				<canvas id="storage-cleanup-chart" class="w-full h-64"></canvas>
				<!-- Hidden data for JavaScript -->
				@templ.JSONScript("cleanup-data", generateCleanupData(cleanupPoints, totalStorage))
			</div>
		} else {
			<div class="text-center py-8 text-gray-400">
				<svg class="w-16 h-16 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
				</svg>
				<p>Not enough data points for graph</p>
			</div>
		}
	</div>
}

templ MediaCard(item models.MediaItem) {
	<div
		class="card overflow-hidden hover:ring-2 hover:ring-indigo-500 transition-all duration-200"
		data-title={ item.Title }
		data-deletion-timestamp={ fmt.Sprintf("%d", item.DeletionDate.Unix()) }
		data-library={ item.Library }
		data-size={ item.FileSize }
	>
		<div class="aspect-w-2 aspect-h-3 bg-gray-800">
			if item.PosterURL != "" {
				<img src={ item.PosterURL } alt={ item.Title } class="w-full h-64 object-cover"/>
			} else {
				<div class="w-full h-64 bg-gray-800 flex items-center justify-center">
					<svg class="w-16 h-16 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 4V2a1 1 0 011-1h8a1 1 0 011 1v2h3a1 1 0 011 1v2a1 1 0 01-1 1h-1v12a2 2 0 01-2 2H6a2 2 0 01-2-2V8H3a1 1 0 01-1-1V5a1 1 0 011-1h3z"></path>
					</svg>
				</div>
			}
		</div>
		<div class="p-4">
			<div class="flex items-start justify-between">
				<div class="flex-1 min-w-0">
					<h3 class="text-lg font-semibold text-gray-100 truncate">{ item.Title }</h3>
					<div class="flex items-center space-x-2 mt-1">
						<span class="inline-flex items-center px-2 py-1 rounded text-xs font-medium bg-gray-700 text-gray-300">
							{ item.Type }
						</span>
						if item.Year > 0 {
							<span class="text-sm text-gray-400">{ fmt.Sprint(item.Year) }</span>
						}
					</div>
				</div>
			</div>
			<div class="mt-3 space-y-2">
				<div class="flex items-center text-sm text-gray-400">
					<svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path>
					</svg>
					{ item.Library }
				</div>
				<div class="flex items-center text-sm text-gray-400">
					<svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
					</svg>
					{ formatFileSize(item.FileSize) }
				</div>
				<div class="flex items-center text-sm text-red-400" title={ formatExactDate(item.DeletionDate) }>
					<svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
					</svg>
					Deletes { formatRelativeTime(item.DeletionDate) }
				</div>
			</div>
			<div class="mt-4">
				if item.HasRequested && !item.MustDelete {
					<button disabled class="w-full flex items-center justify-center btn-secondary opacity-50 cursor-not-allowed">
						<svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
						</svg>
						Request Submitted
					</button>
				} else if item.CanRequest {
					<button id={ "request-" + item.ID } data-media-id={ item.ID } class="w-full flex items-center justify-center btn-primary">
						<svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
						</svg>
						Request to Keep
					</button>
				} else if item.MustDelete {
					<button disabled class="w-full flex items-center justify-center btn-secondary opacity-50 cursor-not-allowed">
						Request Unavailable
					</button>
				}
			</div>
		</div>
	</div>
}

templ EmptyState() {
	<div class="text-center py-12">
		<div class="mx-auto w-24 h-24 bg-gray-800 rounded-full flex items-center justify-center mb-6">
			<svg class="w-12 h-12 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
				<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4"></path>
			</svg>
		</div>
		<h3 class="text-xl font-semibold text-gray-300 mb-2">No media scheduled for deletion</h3>
		<p class="text-gray-500">
			All your media is safe! Check back later or refresh to see if anything changes.
		</p>
	</div>
}

script dashboardScripts() {
	// Initialize all functionality when DOM loads
	document.addEventListener('DOMContentLoaded', function() {
		initializeTabs();
		initializeFilters();
		initializeMediaRequests();
		initializeAutoRefresh();
		initializeStorageChart();	});

	function initializeTabs() {
		const tabButtons = document.querySelectorAll('.tab-button');
		const tabContents = document.querySelectorAll('.tab-content');
		const tabSlider = document.getElementById('tab-slider');

		// Initialize the slider position
		updateSliderPosition();

		tabButtons.forEach(button => {
			button.addEventListener('click', function() {
				const targetTab = this.getAttribute('data-tab');
				
				// Update button states
				tabButtons.forEach(btn => {
					btn.classList.remove('tab-active', 'text-white');
					btn.classList.add('text-gray-400', 'hover:text-gray-200', 'hover:bg-gray-700/30');
				});
				
				this.classList.add('tab-active', 'text-white');
				this.classList.remove('text-gray-400', 'hover:text-gray-200', 'hover:bg-gray-700/30');
				
				// Update slider position with a small delay to ensure DOM is updated
				setTimeout(() => {
					updateSliderPosition();
				}, 10);
				
				// Update content visibility
				tabContents.forEach(content => {
					content.classList.add('hidden');
					content.classList.remove('tab-content-active');
				});
				
				const targetContent = document.getElementById(targetTab + '-content');
				if (targetContent) {
					targetContent.classList.remove('hidden');
					targetContent.classList.add('tab-content-active');
					
					// Reinitialize chart if switching to cleanup timeline tab
					if (targetTab === 'cleanup-timeline') {
						setTimeout(() => {
							initializeStorageChart();
						}, 100);
					}
				}
			});
		});
		
		function updateSliderPosition() {
			const activeTab = document.querySelector('.tab-button.tab-active');
			if (activeTab && tabSlider) {
				// Force a reflow to ensure accurate measurements
				activeTab.offsetHeight;
				
				// Calculate position relative to the nav container
				const navContainer = activeTab.parentElement;
				const containerRect = navContainer.getBoundingClientRect();
				const activeRect = activeTab.getBoundingClientRect();
				
				// Calculate the left position relative to the nav container
				const leftPosition = activeRect.left - containerRect.left;
				
				tabSlider.style.width = activeTab.offsetWidth + 'px';
				tabSlider.style.height = (activeTab.offsetHeight) + 'px';
				tabSlider.style.left = leftPosition + 'px';
				tabSlider.style.top = '0px';
			}
		}
		
		// Update slider on window resize
		window.addEventListener('resize', updateSliderPosition);
	}
	
	function initializeStorageChart() {
		const canvas = document.getElementById('storage-cleanup-chart');
		const dataScript = document.getElementById('cleanup-data');
		
		if (!canvas || !dataScript) return;
		
		try {
			const data = JSON.parse(dataScript.textContent);
			const points = data.points || [];
			
			if (points.length < 2) return;
			
			// Format data for Chart.js
			const chartData = points.map(point => ({
				x: new Date(point.date),
				y: point.cumulativeBytes
			}));
			
			// Initialize Chart.js
			new Chart(canvas, {
				type: 'line',
				data: {
					datasets: [{
						label: 'Storage Freed',
						data: chartData,
						borderColor: 'rgb(34, 197, 94)',
						backgroundColor: 'rgba(34, 197, 94, 0.1)',
						fill: true,
						tension: 0.2,
						pointBackgroundColor: 'rgb(59, 130, 246)',
						pointBorderColor: 'rgb(59, 130, 246)',
						pointRadius: 4,
						pointHoverRadius: 6
					}]
				},
				options: {
					responsive: true,
					maintainAspectRatio: false,
					plugins: {
						legend: {
							display: false
						},
						tooltip: {
							backgroundColor: 'rgba(17, 24, 39, 0.95)',
							titleColor: 'rgb(229, 231, 235)',
							bodyColor: 'rgb(156, 163, 175)',
							borderColor: 'rgb(75, 85, 99)',
							borderWidth: 1,
							callbacks: {
								title: function(context) {
									const date = new Date(context[0].parsed.x);
									return date.toLocaleDateString('en-US', { 
										month: 'short', 
										day: 'numeric',
										year: 'numeric'
									});
								},
								label: function(context) {
									const bytes = context.parsed.y;
									const pointIndex = context.dataIndex;
									const point = points[pointIndex];
									
									return [
										'Storage freed: ' + formatBytes(bytes),
										'Items to delete: ' + point.itemsDeleted
									];
								}
							}
						}
					},
					scales: {
						x: {
							type: 'time',
							time: {
								unit: 'day',
								displayFormats: {
									day: 'MMM d',
									week: 'MMM d',
									month: 'MMM yyyy'
								},
								tooltipFormat: 'MMM d, yyyy'
							},
							grid: {
								color: 'rgba(75, 85, 99, 0.3)'
							},
							ticks: {
								color: 'rgb(156, 163, 175)',
								maxTicksLimit: 30
							}
						},
						y: {
							beginAtZero: true,
							grid: {
								color: 'rgba(75, 85, 99, 0.3)'
							},
							ticks: {
								color: 'rgb(156, 163, 175)',
								callback: function(value) {
									return formatBytes(value);
								}
							}
						}
					},
					interaction: {
						intersect: false,
						mode: 'index'
					}
				}
			});
		} catch (error) {
			console.error('Error initializing storage chart:', error);
		}
	}
	
	function formatBytes(bytes) {
		if (bytes === 0) return '0 Bytes';
		
		const k = 1024;
		const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
		const i = Math.floor(Math.log(bytes) / Math.log(k));
		
		return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
	}

	function initializeFilters() {
		const searchInput = document.getElementById('search');
		const libraryFilter = document.getElementById('library-filter');
		const sortBy = document.getElementById('sort-by');
		const refreshBtn = document.getElementById('refresh-btn');

		if (searchInput) {
			searchInput.addEventListener('input', window.debounce ? window.debounce(filterMedia, 300) : filterMedia);
		}

		if (libraryFilter) {
			libraryFilter.addEventListener('change', filterMedia);
		}

		if (sortBy) {
			sortBy.addEventListener('change', sortMedia);
		}

		if (refreshBtn) {
			refreshBtn.addEventListener('click', refreshMedia);
		}
	}

	function initializeMediaRequests() {
		// Add click handlers for all request buttons
		document.addEventListener('click', function(e) {
			if (e.target.matches('button[data-media-id]')) {
				const mediaId = e.target.getAttribute('data-media-id');
				requestKeepMedia(mediaId, e.target);
			}
		});
	}

	function initializeAutoRefresh() {
		// Auto-refresh every 5 minutes
		setInterval(() => {
			const refreshBtn = document.getElementById('refresh-btn');
			if (refreshBtn && !refreshBtn.disabled) {
				refreshMedia();
			}
		}, 300000); // 5 minutes
	}

	function filterMedia() {
		const searchTerm = document.getElementById('search')?.value.toLowerCase() || '';
		const libraryFilter = document.getElementById('library-filter')?.value || '';

		const mediaCards = document.querySelectorAll('#media-grid > div');

		mediaCards.forEach(card => {
			const title = (card.getAttribute('data-title') || '').toLowerCase();
			const library = card.getAttribute('data-library') || '';

			const matchesSearch = title.includes(searchTerm);
			const matchesLibrary = !libraryFilter || library === libraryFilter;

			if (matchesSearch && matchesLibrary) {
				card.style.display = 'block';
			} else {
				card.style.display = 'none';
			}
		});
	}

	function sortMedia() {
		const sortBy = document.getElementById('sort-by')?.value || 'deletion-date-asc';
		const mediaGrid = document.getElementById('media-grid');

		if (!mediaGrid) return;

		const cards = Array.from(mediaGrid.children);

		cards.sort((a, b) => {
			let aValue, bValue;

			switch (sortBy) {
				case 'title-asc':
					aValue = a.getAttribute('data-title') || '';
					bValue = b.getAttribute('data-title') || '';
					return aValue.localeCompare(bValue);

				case 'title-desc':
					aValue = a.getAttribute('data-title') || '';
					bValue = b.getAttribute('data-title') || '';
					return bValue.localeCompare(aValue);

				case 'deletion-date-asc':
					aValue = parseInt(a.getAttribute('data-deletion-timestamp')) || 0;
					bValue = parseInt(b.getAttribute('data-deletion-timestamp')) || 0;
					return aValue - bValue; // Earlier dates first

				case 'deletion-date-desc':
					aValue = parseInt(a.getAttribute('data-deletion-timestamp')) || 0;
					bValue = parseInt(b.getAttribute('data-deletion-timestamp')) || 0;
					return bValue - aValue; // Later dates first

				default:
					return 0;
			}
		});

		// Re-append sorted cards
		cards.forEach(card => mediaGrid.appendChild(card));
	}

	function requestKeepMedia(mediaId, button) {
		if (!mediaId || button.disabled) return;

		const buttonId = button.id;
		const originalContent = window.setButtonLoading(buttonId, 'Submitting...');
		if (!originalContent) return;

		window.makeApiRequest('/api/media/' + mediaId + '/request-keep')
		.then(data => {
			if (data.success) {
				window.setButtonSuccess(buttonId, 'Request Submitted', '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>');
				
				// Update button styling
				button.classList.remove('btn-primary');
				button.classList.add('btn-secondary', 'opacity-50', 'cursor-not-allowed');

				window.showToast('Request submitted successfully', 'success');
			} else {
				throw new Error(data.message || 'Unknown error');
			}
		})
		.catch(error => {
			console.error('Error:', error);
			window.showToast('Failed to submit request: ' + error.message, 'error');
			window.restoreButton(buttonId, originalContent);
		});
	}

	function refreshMedia() {
		const buttonId = 'refresh-btn';
		const originalContent = window.setButtonLoading(buttonId, 'Refreshing...');
		if (!originalContent) return;

		window.makeApiRequest('/api/refresh')
		.then(data => {
			if (data.success) {
				window.showToast('Data refreshed successfully', 'success');
				// Reload the page to show fresh data
				setTimeout(() => {
					window.location.reload();
				}, 1000);
			} else {
				throw new Error(data.message || 'Failed to refresh data');
			}
		})
		.catch(error => {
			console.error('Error:', error);
			window.showToast('Failed to refresh data: ' + error.message, 'error');
			window.restoreButton(buttonId, originalContent);
		});
	}
}

templ OverviewTab(mediaItems []models.MediaItem) {
	<!-- Filters and Search -->
	<div class="card p-6 mb-6">
		<div class="flex flex-col lg:flex-row lg:items-center lg:justify-between space-y-4 lg:space-y-0 lg:space-x-4">
			<div class="flex flex-col sm:flex-row sm:items-center space-y-4 sm:space-y-0 sm:space-x-4">
				<div class="relative">
					<input type="text" id="search" placeholder="Search media..." class="input-field pl-10 pr-4 py-2 w-full sm:w-64"/>
					<div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
						<svg class="h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
						</svg>
					</div>
				</div>
				<select id="library-filter" class="input-field">
					<option value="">All Libraries</option>
					for _, library := range getUniqueLibraries(mediaItems) {
						<option value={ library }>{ library }</option>
					}
				</select>
				<select id="sort-by" class="input-field">
					<option value="deletion-date-asc">Deletion Date (Earliest First)</option>
					<option value="deletion-date-desc">Deletion Date (Latest First)</option>
					<option value="title-asc">Title (A-Z)</option>
					<option value="title-desc">Title (Z-A)</option>
				</select>
			</div>
			<div class="flex items-center space-x-2">
				<button id="refresh-btn" class="flex items-center justify-center btn-secondary">
					<svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
					</svg>
					Refresh
				</button>
			</div>
		</div>
	</div>
	<!-- Media Grid -->
	if len(mediaItems) == 0 {
		@EmptyState()
	} else {
		<div id="media-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
			for _, item := range mediaItems {
				@MediaCard(item)
			}
		</div>
	}
}

templ StatsTab(mediaItems []models.MediaItem) {
	@StorageCleanupGraph(calculateStorageCleanupData(mediaItems), getTotalStorageToFree(mediaItems))
}
